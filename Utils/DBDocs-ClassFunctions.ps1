<#
    A Utility script that handles the Project creation for the DBDocs integration
    Done by Geoffrey Bessereau, 2020-05-18
    Declares Functions to handle the DBDocs Objects.
    Functions that consume the XML that Salesforce returns and initiates instances of the Classes for DB Ddocs, before returning them.
#>

function Create-DefaultEnum {
    [OutputType([Field])]
    $DefaultValue = [PicklistValue]::new("Standard fields are handled by Salesforce internally")
    $DefaultEnum = [Picklist]::new("Default",$DefaultValue)
    Write-Output $DefaultEnum -NoEnumerate
}

function Create-Picklist {
    [OutputType([Picklist])]
    param(
        [Parameter(mandatory=$true)]
        [System.Object]$Field
    )
    $thisPicklist = [Picklist]::new()
    return $thisPicklist

}

function Create-Field {
    [OutputType([Field])]
    param(
        [Parameter(mandatory=$true)]
        [System.Object]$Field,
        [String]$Object
    )

    # Create instance of the field
    [Field]$thisField = [Field]::new()

    # Set basic info
    $thisField.Name = $field.fullname
    If($field.description){
        $thisField.Description = $field.description.Replace('"',"")
    }
    If($field.defaultValue){
        $thisField.Default = $field.defaultValue.Replace('"',"")
    }
    $thisField.Type = $field.type

    # Add Standard field type as those fields don't have Type property
    If (-NOT (Get-Member -inputobject $thisField -name "type" -Membertype Properties)) {
        $thisField.Description = "Standard_Field"
    }

    # Handle Picklists
    If ( $field.type -eq "Picklist" ) {
        If (Get-Member -inputobject $field -name "valueSet" -Membertype Properties) {
            $tmpfield = Trim-SalesforceCustomSuffix($Field.fullName)
            $tmpobj = Trim-SalesforceCustomSuffix($Object)
            $thisField.Type = $tmpobj + "_" + $tmpfield
        } Else {
            $thisField.Type = "Default"
        }
    }

    # Handle Lookups and Master Details as References in DBML
    If ( $field.type -eq "Lookup" -OR $field.type -eq "MasterDetail") {
        If (-NOT (Get-Member -inputobject $field -name "referenceTo" -Membertype Properties)) {

            #  If ReferenceTo isn't populated, it's a standard field in which case we generate the reference from the field name.
            If ( $field.fullName -eq "OwnerId") { $Reference = "User" } Else { $Reference = $field.fullName }
            If ( $Reference.Substring($Reference.Length -2) -eq "Id") { $Reference = $Reference.Substring(0,$Reference.Length -2) } 
            $thisField.Reference = $Reference
        } Else {
            $thisField.Reference = $field.referenceTo
        }
    }

    If ( -NOT $thisField.Type) {
        $thisField.Type = "StandardField"
    }
    Write-Output $thisField -NoEnumerate
}

function Create-Table {
    param(
        [Parameter(mandatory=$true)]
        [System.Xml.XmlElement]$Table,
        [Parameter(mandatory=$true)]
        [String]$TableName
    )
    [Table]$thisTable = [Table]::new($TableName)
    [System.Collections.Generic.List[Field]]$thisFields = @()
    

    # Add the ID field which is constant on all objects
    $idField = [Field]::new("id","string",$null,$null,"Generated by automatically by System", "increment, pk")
    $thisFields.Add($idField)

    # Record Types are at the root of the XML so we need to process them here
    If (Get-Member -inputobject $Table -name "recordTypes" -Membertype Properties){
        $TableNameNoSuffix = Trim-SalesforceCustomSuffix($TableName)
        $thisRecordTypeName = $TableNameNoSuffix + "_recordtype"
        [Field]$RecordType = [Field]::new("RecordTypes", $thisRecordTypeName, $null, "Master", "Splits Permissions and access by Type", "")
        $thisfields.add($RecordType)
    }

    # Name fields are also at the root of the XML so we handle them here
    If (Get-Member -inputobject $Table -name "nameField" -Membertype Properties){
        If ($Table.nameField.type -eq "AutoNumber"){
            [Field]$NameField = [Field]::new("Name", "AutoNumber", $null, $null, $Table.nameField.displayFormat, "increment")
            $thisfields.add($NameField)
        }Else{
            [Field]$NameField = [Field]::new("Name", "String", $null, $null, "Limited to 80 characters", "")
            $thisfields.add($NameField)
        }
    } 

    # Iterate over fields and create objects as needed
    [string[]]$FieldsToExclude = Get-Content -Path '.\Config\Exclusion-Fields.txt'
    [string[]]$RefsToExclude = Get-Content -Path '.\Config\Exclusion-References.txt'
    ForEach ($field in $Table.fields) {
        If(-NOT ($FieldsToExclude.Contains($field.fullname) -OR $RefsToExclude.Contains($field.referenceTo))  ){
            [Field]$thisField = Create-Field -Field $field -Object $TableName
            $thisFields.Add($thisField)
        }
    }

    # Add fields to object and return
    $thisTable.Fields = $thisFields
    If ($Table.description){
        $thisTable.Description = $Table.description.Replace('"','')
    }
    return $thisTable
}

function Create-Project {
    param (
        [Parameter(mandatory=$true)]
        [string]$dbdocsname,
        [string]$dbdocsnotes,
        [string]$dbdocsdbtype,
        [Parameter(mandatory=$true)]
        [string]$path
    )
    [Project]$DbDocsProject = [Project]::new($dbdocsname,$dbdocsnotes,$dbdocsdbtype)
    $DbDocsProject.Tables = Merge-Tables -path $path
    $DbDocsProject.Enums = Merge-Picklists -path $path
    return $DbDocsProject
}

<#
    Functions that collate records together when the parent expects a collection
#>
function Merge-Tables {
    param (
        [Parameter(mandatory=$true)]
        [string]$path
    )
    [System.Collections.Generic.List[Table]]$thisTables = @()
    Get-ChildItem "$path" -Filter *.object | 
    Foreach-Object {
        [xml]$content = Get-Content $_.FullName -Encoding UTF8
        $ObjName = Get-ObjectName($_.Name) -RemoveSuffix $False
        
        # Allow Exclusion of certain tables from documentation
        [string[]]$TablesToExclude = Get-Content -Path '.\Config\Exclusion-Tables.txt'
        If(-NOT $TablesToExclude.Contains($ObjName)){
            $thisTable = Create-Table -Table $content.CustomObject -TableName $ObjName
            $thisTables.Add($thisTable)
        }
    }
    return $thisTables
}

function Merge-Picklists {
    param (
        [Parameter(mandatory=$true)]
        [string]$path
    )
    <#
        We handle picklists here because of the structure of DBML.
        We pretty much do the same operation that Merge-Tables does but only for picklists.
        It's slightly more CPU intensive but at least the functions are independent.
    #>

    # Create Default enumerator for the case where we have Standard picklists
    $DefaultEnum = Create-DefaultEnum
    [System.Collections.Generic.List[Picklist]]$thisPicklists = @()
    $thisPicklists.add($DefaultEnum)
    Get-ChildItem "$path" -Filter *.object | 
    Foreach-Object {
        [xml]$content = Get-Content $_.FullName -Encoding UTF8
        $ObjNameTrimmed = Get-ObjectName($_.Name) -RemoveSuffix $True
        

        # Handle all Field picklists
        ForEach ($field in $content.CustomObject.fields) {
        
            # Ignore anything that isn't a picklist
            If ( $field.type -eq "Picklist" ) {
                [System.Collections.Generic.List[PicklistValue]]$thisPicklistValues = @()
                If (Get-Member -inputobject $field -name "valueSet" -Membertype Properties) {
                    If (Get-Member -inputobject $field.valueSet -name "valueSetDefinition" -Membertype Properties) {
                        ForEach ($value in $field.valueSet.valueSetDefinition.value) {
                            $thisPicklistValue = [PicklistValue]::new($value.fullName)
                            $thisPicklistValues.add($thisPicklistValue)
                        }
                    }
                } Else {
                    # Picklists with no valuesets are standard picklists.
                    $StandardValue = [PicklistValue]::new("Standard Picklist Values are handled by Salesforce internally")
                    $thisPicklistValues.add($StandardValue)
                    $thisPicklistName += "Standard"
                }
                $FieldNameNoSuffix = Trim-SalesforceCustomSuffix($field.fullName)
                $thisPicklistName += $ObjNameTrimmed + "_" + $FieldNameNoSuffix
                If($thisPicklistValues.Count -eq 0){
                   $DefaultValue = [PicklistValue]::new("Inactive")
                   $thisPicklistValues.add($DefaultValue)
                }
                $thisPicklist = [Picklist]::new($thisPicklistName,$thisPicklistValues)
                $thisPicklists.add($thisPicklist)
                $thisPicklistName = $null
            }
        }

        # Handle all RecordType picklists
        If (Get-Member -inputobject $content.CustomObject -name "recordTypes" -Membertype Properties){
            $thisRecordType = Create-RecordTypes -Object $content.CustomObject -TableName $ObjNameTrimmed
            $thisPicklists.add($thisRecordType)
        }

    }
    Write-Output $thisPicklists -NoEnumerate
}

function Create-RecordTypes {
    param (
        [Parameter(mandatory=$true)]
        [System.Xml.XmlElement]$Object,
        [Parameter(mandatory=$true)]
        [String]$TableName
    )
    
    # Ignore all objects that don't have RecordTypes

    [System.Collections.Generic.List[PicklistValue]]$thisRecordTypeValues = @()
    $TableNameNoSuffix = Trim-SalesforceCustomSuffix($TableName)
    [string]$thisRecordTypeName = $TableNameNoSuffix + "_recordtype"
    ForEach ($RecordType in $Object.recordTypes) {
        $thisRecordTypeValues.add([PicklistValue]::new($RecordType.fullName))
    }
    $thisRecordType = [Picklist]::new($thisRecordTypeName,$thisRecordTypeValues)
    Write-Output $thisRecordType -NoEnumerate
}
